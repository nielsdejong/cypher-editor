{"columns":["name","signature","description","roles"],"data":[{"row":["apoc.algo.aStar","apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)","apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.aStarConfig","apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)","apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.allSimplePaths","apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)","apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.betweenness","apoc.algo.betweenness(types :: LIST? OF STRING?, nodes :: LIST? OF NODE?, direction :: STRING?) :: (node :: NODE?, score :: FLOAT?)","CALL apoc.algo.betweenness(['TYPE',...],nodes,BOTH) YIELD node, score - calculate betweenness centrality for given nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.betweennessCypher","apoc.algo.betweennessCypher(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)","CALL apoc.algo.betweennessCypher(node_cypher,rel_cypher,write) - calculates betweeness  centrality based on cypher input",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.cliques","apoc.algo.cliques(minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)","apoc.algo.cliques(minSize) YIELD cliques - search the graph and return all maximal cliques at least at large as the minimum size argument.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.cliquesWithNode","apoc.algo.cliquesWithNode(startNode :: NODE?, minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)","apoc.algo.cliquesWithNode(startNode, minSize) YIELD cliques - search the graph and return all maximal cliques that are at least as large than the minimum size argument and contain this node ",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.closeness","apoc.algo.closeness(types :: LIST? OF STRING?, nodes :: LIST? OF NODE?, direction :: STRING?) :: (node :: NODE?, score :: FLOAT?)","CALL apoc.algo.closeness(['TYPE',...],nodes, INCOMING) YIELD node, score - calculate closeness centrality for given nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.community","apoc.algo.community(times :: INTEGER?, labels :: LIST? OF STRING?, partitionKey :: STRING?, type :: STRING?, direction :: STRING?, weightKey :: STRING?, batchSize :: INTEGER?) :: VOID","CALL apoc.algo.community(times,labels,partitionKey,type,direction,weightKey,batchSize) - simple label propagation kernel",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.cover","apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?)","apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.dijkstra","apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)","apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance') YIELD path, weight - run dijkstra with relationship property name as cost function",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.dijkstraWithDefaultWeight","apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)","apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.pageRank","apoc.algo.pageRank(nodes :: LIST? OF NODE?) :: (node :: NODE?, score :: FLOAT?)","CALL apoc.algo.pageRank(nodes) YIELD node, score - calculates page rank for given nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.pageRankStats","apoc.algo.pageRankStats(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)","CALL apoc.algo.pageRankStats({iterations:_,types:_,write:true,...}) YIELD nodeCount - calculates page rank on graph  for given nodes and potentially writes back",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.pageRankWithConfig","apoc.algo.pageRankWithConfig(nodes :: LIST? OF NODE?, config :: MAP?) :: (node :: NODE?, score :: FLOAT?)","CALL apoc.algo.pageRankWithConfig(nodes,{iterations:_,types:_}) YIELD node, score, info - calculates page rank for given nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.pageRankWithCypher","apoc.algo.pageRankWithCypher(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)","CALL apoc.algo.pageRankWithCypher({iterations,node_cypher,rel_cypher,write,property,numCpu}) - calculates page rank based on cypher input",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.algo.wcc","apoc.algo.wcc() :: (nodeIds :: LIST? OF INTEGER?, stats :: MAP?)","CALL apoc.algo.wcc() YIELD number of weakly connected components",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.bitwise.op","apoc.bitwise.op(a :: INTEGER?, operator :: STRING?, b :: INTEGER?) :: (value :: INTEGER?)","apoc.bitwise.op(60,'|',13) bitwise operations a & b, a | b, a ^ b, ~a, a >> b, a >>> b, a << b. returns the result of the bitwise operation",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cluster.graph","apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.coll.partition","apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)","apoc.coll.partition(list,batchSize)",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.coll.split","apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)","apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.coll.zipToRows","apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)","apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.config.list","apoc.config.list() :: (key :: STRING?, value :: ANY?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.config.map","apoc.config.map() :: (value :: MAP?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.convert.setJsonProperty","apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID","apoc.json.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.convert.toTree","apoc.convert.toTree(paths :: LIST? OF PATH?) :: (value :: MAP?)","apoc.convert.toTree([paths]) creates a stream of nested documents representing the at least one root of these paths",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.append","apoc.couchbase.append(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.append(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.exists","apoc.couchbase.exists(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?) :: (value :: BOOLEAN?)","apoc.couchbase.exists(nodes, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.get","apoc.couchbase.get(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.get(nodes, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.insert","apoc.couchbase.insert(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.insert(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.namedParamsQuery","apoc.couchbase.namedParamsQuery(nodes :: LIST? OF STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)","apoc.couchbase.namedParamsQuery(nodes, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.posParamsQuery","apoc.couchbase.posParamsQuery(nodes :: LIST? OF STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)","apoc.couchbase.posParamsQuery(nodes, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.prepend","apoc.couchbase.prepend(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.prepend(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.query","apoc.couchbase.query(nodes :: LIST? OF STRING?, bucket :: STRING?, statement :: STRING?) :: (queryResult :: LIST? OF MAP?)","apoc.couchbase.query(nodes, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.remove","apoc.couchbase.remove(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.remove(nodes, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.replace","apoc.couchbase.replace(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.replace(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.couchbase.upsert","apoc.couchbase.upsert(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)","apoc.couchbase.upsert(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.addLabels","apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)","apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.node","apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)","apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.nodes","apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)","apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.relationship","apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)","apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.removeLabels","apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)","apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.setLabels","apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)","apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.setProperties","apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)","apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given property on the nodes(s)",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.setProperty","apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)","apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.setRelProperties","apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)","apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given property on the relationship(s)",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.setRelProperty","apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)","apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.uuids","apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)","apoc.create.uuids(count) yield uuid - creates 'count' UUIDs ",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.vNode","apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)","apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.vNodes","apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)","apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.vPattern","apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)","apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.vPatternFull","apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)","apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.create.vRelationship","apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)","apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.doit","apoc.cypher.doit(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)","apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.mapParallel","apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)","apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.mapParallel2","apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?) :: (value :: MAP?)","apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.parallel","apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.parallel2","apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.run","apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)","apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.runFile","apoc.cypher.runFile(file :: STRING?) :: (row :: INTEGER?, result :: MAP?)","apoc.cypher.runFile(file or url) - runs each statement in the file, all semicolon separated - currently no schema operations",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.runMany","apoc.cypher.runMany(cypher :: STRING?, params :: MAP?) :: (row :: INTEGER?, result :: MAP?)","apoc.cypher.runMany('cypher;\\nstatements;',{params}) - runs each semicolon separated statement and returns summary - currently no schema operations",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.cypher.runTimeboxed","apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)","apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort statement after timeout ms if not finished",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.date.expire","apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID","CALL apoc.date.expire(node,time,'time-unit') - expire node in given time by setting :TTL label and `ttl` property",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.date.expireIn","apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID","CALL apoc.date.expire.in(node,time,'time-unit') - expire node in given time-delta by setting :TTL label and `ttl` property",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.get","apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)","apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.getRaw","apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)","apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.post","apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)","apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.postRaw","apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)","apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.put","apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)","apoc.es.put(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.query","apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)","apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.es.stats","apoc.es.stats(host :: STRING?) :: (value :: MAP?)","apoc.es.stats(host-url-Key) - elastic search statistics",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.example.movies","apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.example.movies() | Creates the sample movies graph",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.csv.all","apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.csv.data","apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.csv.graph","apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.csv.query","apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypher.all","apoc.export.cypher.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypher.data","apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypher.graph","apoc.export.cypher.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypher.query","apoc.export.cypher.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypherAll","apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypherData","apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypherGraph","apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.cypherQuery","apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.graphml.all","apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.graphml.data","apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.graphml.graph","apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.export.graphml.query","apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.generate.ba","apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID","apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.generate.complete","apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID","apoc.generate.complete(noNodes, label, type) - generates a random complete graph",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.generate.er","apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID","apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.generate.simple","apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID","apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.generate.ws","apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID","apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.gephi.add","apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.gephi.add(url-or-key, workspace, data) | streams passed in data to Gephi",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.get.nodes","apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)","apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id's",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.get.rels","apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)","apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.graph.from","apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)","apoc.graph.from(data,'name',{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.graph.fromCypher","apoc.graph.fromCypher(statement :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)","apoc.graph.fromCypher('statement',{params},'name',{properties}) - creates a virtual graph object for later processing",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.graph.fromDB","apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)","apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.graph.fromData","apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)","apoc.graph.fromData([nodes],[relationships],'name',{properties}) | creates a virtual graph object for later processing",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.graph.fromPath","apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)","apoc.graph.fromPaths(path,'name',{properties}) - creates a virtual graph object for later processing",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.graph.fromPaths","apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)","apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.help","apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?)","Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.import.graphml","apoc.import.graphml(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)","apoc.import.graphml(file,config) - imports graphml file",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.addAllNodes","apoc.index.addAllNodes(index :: STRING?, structure :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)","apoc.index.addAllNodes('name',{label1:['prop1',...],...}) YIELD type, name, config - create a free text search index",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.addAllNodesExtended","apoc.index.addAllNodesExtended(index :: STRING?, structure :: MAP?, options :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)","apoc.index.addAllNodes('name',{label1:['prop1',...],...}, {options}) YIELD type, name, config - create a free text search index with special options",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.addNode","apoc.index.addNode(node :: NODE?, properties :: LIST? OF STRING?) :: VOID","apoc.index.addNode(node,['prop1',...]) add node to an index for each label it has",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.addNodeByLabel","apoc.index.addNodeByLabel(label :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID","apoc.index.addNodeByLabel(node,'Label',['prop1',...]) add node to an index for the given label",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.addRelationship","apoc.index.addRelationship(relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID","apoc.index.addRelationship(rel,['prop1',...]) add relationship to an index for its type",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.between","apoc.index.between(from :: NODE?, type :: STRING?, to :: NODE?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)","apoc.index.between(node1,'TYPE',node2,'prop:value*') YIELD rel - lucene query on relationship index with the given type name bound by either or both sides (each node parameter can be null)",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.forNodes","apoc.index.forNodes(name :: STRING?, config :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","apoc.index.forNodes('name',{config}) YIELD type,name,config - gets or creates node index",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.forRelationships","apoc.index.forRelationships(name :: STRING?, config :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","apoc.index.forRelationships('name',{config}) YIELD type,name,config - gets or creates relationship index",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.in","apoc.index.in(to :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)","apoc.index.in(node,'TYPE','prop:value*') YIELD node lucene query on relationship index with the given type name for *incoming* relationship of the given node, *returns start-nodes*",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.list","apoc.index.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)","apoc.index.list() - YIELD type,name,config - lists all manual indexes",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.nodes","apoc.index.nodes(label :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)","apoc.index.nodes('Label','prop:value*') YIELD node - lucene query on node index with the given label name",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.orderedByText","apoc.index.orderedByText(label :: STRING?, key :: STRING?, operator :: STRING?, value :: STRING?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)","apoc.index.orderedByText(label,key,operator,value,sort-relevance,limit) yield node - schema string search which keeps index order and adds limit, operator is 'STARTS WITH' or 'CONTAINS'",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.orderedRange","apoc.index.orderedRange(label :: STRING?, key :: STRING?, min :: ANY?, max :: ANY?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)","apoc.index.orderedRange(label,key,min,max,sort-relevance,limit) yield node - schema range scan which keeps index order and adds limit, values can be null, boundaries are inclusive",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.out","apoc.index.out(from :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)","apoc.index.out(node,'TYPE','prop:value*') YIELD node - lucene query on relationship index with the given type name for *outgoing* relationship of the given node, *returns end-nodes*",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.related","apoc.index.related(nodes :: LIST? OF NODE?, label :: STRING?, key :: STRING?, relationship :: STRING?, limit :: INTEGER?) :: (node :: NODE?)","apoc.index.relatedNodes([nodes],label,key,'<TYPE'/'TYPE>'/'TYPE',limit) yield node - schema range scan which keeps index order and adds limit and checks opposite node of relationship against the given set of nodes",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.relationships","apoc.index.relationships(type :: STRING?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)","apoc.index.relationships('TYPE','prop:value*') YIELD rel - lucene query on relationship index with the given type name",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.remove","apoc.index.remove(name :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","apoc.index.remove('name') YIELD type,name,config - removes an manual index",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.index.search","apoc.index.search(index :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)","apoc.index.search('name', 'query') YIELD node, weight - search for nodes in the free text index matching the given query",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.csv","apoc.load.csv(url :: STRING?, config :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, map :: MAP?)","apoc.load.csv('url',{config}) YIELD lineNo, list, map - load CSV fom URL as stream of values,\n config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.driver","apoc.load.driver(driverClass :: STRING?) :: VOID","apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.jdbc","apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?) :: (row :: MAP?)","apoc.load.jdbc('key or url','table or statement') YIELD row - load from relational database, from a full table or a sql statement",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.jdbcParams","apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?) :: (row :: MAP?)","apoc.load.jdbcParams('key or url','statement',[params]) YIELD row - load from relational database, from a sql statement with parameters",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.json","apoc.load.json(url :: STRING?) :: (value :: MAP?)","apoc.load.json('url') YIELD value -  import JSON as stream of values if the JSON was an array or a single value if it was a map",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.jsonArray","apoc.load.jsonArray(url :: STRING?) :: (value :: ANY?)","apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.jsonParams","apoc.load.jsonParams(url :: STRING?, headers :: MAP?, payload :: STRING?) :: (value :: MAP?)","apoc.load.jsonParams('url',{header:value},payload) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.xml","apoc.load.xml(url :: STRING?) :: (value :: MAP?)","apoc.load.xml('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.load.xmlSimple","apoc.load.xmlSimple(url :: STRING?) :: (value :: MAP?)","apoc.load.xml('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.lock.all","apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID","apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.lock.nodes","apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID","apoc.lock.nodes([nodes]) acquires a write lock on the given nodes",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.lock.rels","apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID","apoc.lock.rels([relationships]) acquires a write lock on the given relationship",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.meta.data","apoc.meta.data() :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?)","apoc.meta.data  - examines a subset of the graph to provide a tabular meta information",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.meta.graph","apoc.meta.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","apoc.meta.graph - examines the full graph to create the meta-graph",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.meta.graphSample","apoc.meta.graphSample() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.meta.stats","apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, stats :: MAP?)","apoc.meta.stats  yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.meta.subGraph","apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.count","apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)","apoc.mongodb.count(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.delete","apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)","apoc.mongodb.delete(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.find","apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?) :: (value :: MAP?)","apoc.mongodb.find(host-or-port,db-or-null,collection-or-null,query-or-null,projection-or-null,sort-or-null) yield value - perform a find,project,sort operation on mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.first","apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: MAP?)","apoc.mongodb.first(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a first operation on mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.get","apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: MAP?)","apoc.mongodb.get(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.insert","apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID","apoc.mongodb.insert(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.mongodb.update","apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)","apoc.mongodb.update(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.monitor.ids","apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)","apoc.monitor.ids() returns the object ids in use for this neo4j instance",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.monitor.kernel","apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)","apoc.monitor.kernel() returns informations about the neo4j kernel",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.monitor.locks","apoc.monitor.locks(minWaitTime :: INTEGER?) :: (advertedDeadLocks :: INTEGER?, lockCount :: INTEGER?, contendedLockCount :: INTEGER?, minimumWaitTimeMs :: INTEGER?, contendedLocks :: LIST? OF MAP?, info :: STRING?)","apoc.monitor.locks(minWaitTime) yield advertedDeadLocks, lockCount, contendedLockCount, minimumWaitTimeMs, contendedLocks, info",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.monitor.store","apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)","apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.monitor.tx","apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)","apoc.monitor.tx() returns informations about the neo4j transaction manager",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.nodes.delete","apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)","apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these id's",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.nodes.get","apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?)","apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these id's",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.nodes.link","apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?) :: VOID","apoc.nodes.link([nodes],'REL_TYPE') - creates a linked list of nodes from first to last",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.nodes.rels","apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)","apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.path.expand","apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)","apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path expand from start node following the given relationships from min to max-level adhering to the label filters",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.path.expandConfig","apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)","apoc.path.expandConfig(startNode <id>|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true}) yield path expand from start node following the given relationships from min to max-level adhering to the label filters",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.cancel","apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)","apoc.periodic.cancel(name) - cancel job with the given name",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.commit","apoc.periodic.commit(statement :: STRING?, params :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, faileBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?)","apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.iterate","apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?)","apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,parallel:true}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.list","apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)","apoc.periodic.list - list all jobs",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.repeat","apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)","apoc.periodic.schedule('name',statement,repeat-time-in-seconds) submit a repeatedly-called background statement",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.rock_n_roll","apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?)","apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.rock_n_roll_while","apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)","apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.periodic.submit","apoc.periodic.submit(name :: STRING?, statement :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)","apoc.periodic.submit('name',statement) - submit a one-off background statement",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.categorize","apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID","apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.cloneNodes","apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)","apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.cloneNodesWithRelationships","apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)","apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.collapseNode","apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)","apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.extractNode","apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)","apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.from","apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)","apoc.refactor.from(rel, startNode) redirect relationship to use new start-node",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.invert","apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)","apoc.refactor.invert(rel) inverts relationship direction",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.mergeNodes","apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?) :: (node :: NODE?)","apoc.refactor.mergeNodes([node1,node2]) merge nodes onto first in list",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.normalizeAsBoolean","apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID","apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.setType","apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)","apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.refactor.to","apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)","apoc.refactor.to(rel, endNode) redirect relationship to use new end-node",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.schema.assert","apoc.schema.assert(indexes :: MAP?, constraints :: MAP?) :: (label :: STRING?, key :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)","",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.schema.properties.distinct","apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)","apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.search.multiSearchReduced","apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)","Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.search.node","apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)","Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.search.nodeAll","apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)","Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.search.nodeAllReduced","apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)","Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH / = / <> / < / > ..., value ). All 'hits' are returned.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.search.nodeReduced","apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)","Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.spatial.geocode","apoc.spatial.geocode(location :: STRING?, maxResults :: INTEGER?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)","apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from openstreetmap geocoding service",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.spatial.geocodeOnce","apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)","apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from openstreetmap geocoding service",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.spatial.sortByDistance","apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)","apoc.spatial.sortPathsByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.static.get","apoc.static.get(key :: STRING?) :: (value :: ANY?)","apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.static.getAll","apoc.static.getAll(prefix :: STRING?) :: (value :: MAP?)","apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.static.list","apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)","apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.static.set","apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)","apoc.static.set(name, value) - stores value under key for server livetime storage, returns previously stored or configured value",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.text.format","apoc.text.format(text :: STRING?, params :: LIST? OF ANY?) :: (value :: STRING?)","apoc.text.format(text,[params]) YIELD value - sprintf format the string with the params given",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.text.lpad","apoc.text.lpad(text :: STRING?, count :: INTEGER?, delim :: STRING?) :: (value :: STRING?)","apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.text.phonetic","apoc.text.phonetic(value :: ANY?) :: (value :: STRING?)","apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.text.phoneticDelta","apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)","apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.text.rpad","apoc.text.rpad(text :: STRING?, count :: INTEGER?, delim :: STRING?) :: (value :: STRING?)","apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.trigger.add","apoc.trigger.add(name :: STRING?, statement :: STRING?, selector :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, installed :: BOOLEAN?)","",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.trigger.list","apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, installed :: BOOLEAN?)","",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.trigger.remove","apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, installed :: BOOLEAN?)","",["publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.util.sleep","apoc.util.sleep(duration :: INTEGER?) :: VOID","apoc.util.sleep(<duration>) | sleeps for <duration> millis, transaction termination is honored",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["apoc.warmup.run","apoc.warmup.run() :: (pageSize :: INTEGER?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, totalTime :: INTEGER?)","apoc.warmup.run() - quickly loads all nodes and rels into memory by skipping one page at a time",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.awaitIndex","db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for an index to come online (for example: CALL db.awaitIndex(\":Person(name)\")).",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.constraints","db.constraints() :: (description :: STRING?)","List all constraints in the database.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.indexes","db.indexes() :: (description :: STRING?, state :: STRING?, type :: STRING?)","List all indexes in the database.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.labels","db.labels() :: (label :: STRING?)","List all labels in the database.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.propertyKeys","db.propertyKeys() :: (propertyKey :: STRING?)","List all property keys in the database.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.relationshipTypes","db.relationshipTypes() :: (relationshipType :: STRING?)","List all relationship types in the database.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.resampleIndex","db.resampleIndex(index :: STRING?) :: VOID","Schedule resampling of an index (for example: CALL db.resampleIndex(\":Person(name)\")).",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.resampleOutdatedIndexes","db.resampleOutdatedIndexes() :: VOID","Schedule resampling of all outdated indexes.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["db.schema","db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","Show the schema of the data.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.changePassword","dbms.changePassword(password :: STRING?) :: VOID","Change the current user's password. Deprecated by dbms.security.changePassword.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.components","dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)","List DBMS components and their versions.",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.functions","dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?, roles :: LIST? OF STRING?)","List all user functions in the DBMS.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.killQueries","dbms.killQueries(ids :: LIST? OF STRING?) :: (queryId :: STRING?, username :: STRING?)","Kill all transactions executing a query with any of the given query ids.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.killQuery","dbms.killQuery(id :: STRING?) :: (queryId :: STRING?, username :: STRING?)","Kill all transactions executing the query with the given query id.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.listQueries","dbms.listQueries() :: (queryId :: STRING?, username :: STRING?, query :: STRING?, parameters :: MAP?, startTime :: STRING?, elapsedTime :: STRING?, connectionDetails :: STRING?, metaData :: MAP?)","List all queries currently executing at this instance that are visible to the user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.procedures","dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, roles :: LIST? OF STRING?)","List all procedures in the DBMS.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.queryJmx","dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)","Query JMX management data by domain and name. For instance, \"org.neo4j:*\"",["reader","publisher","architect","admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.activateUser","dbms.security.activateUser(username :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID","Activate a suspended user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.addRoleToUser","dbms.security.addRoleToUser(roleName :: STRING?, username :: STRING?) :: VOID","Assign a role to the user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.changePassword","dbms.security.changePassword(password :: STRING?, requirePasswordChange = false :: BOOLEAN?) :: VOID","Change the current user's password.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.changeUserPassword","dbms.security.changeUserPassword(username :: STRING?, newPassword :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID","Change the given user's password.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.clearAuthCache","dbms.security.clearAuthCache() :: VOID","Clears authentication and authorization cache.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.createRole","dbms.security.createRole(roleName :: STRING?) :: VOID","Create a new role.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.createUser","dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID","Create a new user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.deleteRole","dbms.security.deleteRole(roleName :: STRING?) :: VOID","Delete the specified role. Any role assignments will be removed.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.deleteUser","dbms.security.deleteUser(username :: STRING?) :: VOID","Delete the specified user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.listRoles","dbms.security.listRoles() :: (role :: STRING?, users :: LIST? OF STRING?)","List all available roles.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.listRolesForUser","dbms.security.listRolesForUser(username :: STRING?) :: (value :: STRING?)","List all roles assigned to the specified user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.listUsers","dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)","List all local users.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.listUsersForRole","dbms.security.listUsersForRole(roleName :: STRING?) :: (value :: STRING?)","List all users currently assigned the specified role.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.removeRoleFromUser","dbms.security.removeRoleFromUser(roleName :: STRING?, username :: STRING?) :: VOID","Unassign a role from the user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.showCurrentUser","dbms.security.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)","Show the current user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.security.suspendUser","dbms.security.suspendUser(username :: STRING?) :: VOID","Suspend the specified user.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}},{"row":["dbms.setTXMetaData","dbms.setTXMetaData(data :: MAP?) :: VOID","Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.",["admin"]],"meta":[null,null,null,null],"graph":{"nodes":[],"relationships":[]}}],"stats":{"nodes_created":0,"nodes_deleted":0,"relationships_created":0,"relationships_deleted":0,"properties_set":0,"labels_added":0,"labels_removed":0,"indexes_added":0,"indexes_removed":0,"constraints_added":0,"constraints_removed":0,"contains_updates":false}}